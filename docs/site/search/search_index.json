{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/eemeter/eemeter/","title":"<code>DailyModel</code> Class","text":"<p>options:     members:         - DailyModel</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily","title":"<code>eemeter.eemeter.models.daily</code>","text":"<p>Copyright 2014-2024 OpenEEmeter contributors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData","title":"<code>DailyBaselineData(df, is_electricity_data)</code>","text":"<p>Data class to represent Daily Baseline Data. Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData--parameters","title":"Parameters","text":"<ol> <li> <p>data : A dataframe having a datetime index or a datetime column with the timezone also being set.     It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data.     The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> </li> <li> <p>is_electricity_data : boolean flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> </li> </ol>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData--returns","title":"Returns","text":"<p>An instance of the DailyBaselineData class.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData--public-attributes","title":"Public Attributes","text":"<ol> <li>df : Immutable dataframe that contains the meter and temperature values for the baseline data period.</li> <li>disqualification : Serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them,                         set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</li> <li>warnings : Issues with the data, but not that will severely reduce the quality of the model built.</li> </ol>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData--public-methods","title":"Public Methods","text":"<ol> <li> <p>from_series: Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe.                 The temperature column should have values in Fahrenheit.</p> </li> <li> <p>log_warnings: View the disqualifications and warnings associated with the current data input provided.</p> </li> </ol> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    self._df = None\n    self.warnings = []\n    self.disqualification = []\n    self.is_electricity_data = is_electricity_data\n    self.tz = None\n\n    # TODO re-examine dq/warning pattern. keep consistent between\n    # either implicitly setting as side effects, or returning and assigning outside\n    self._df, temp_coverage = self._set_data(df)\n\n    sufficiency_df = self._df.merge(\n        temp_coverage, left_index=True, right_index=True, how=\"left\"\n    )\n    disqualification, warnings = self._check_data_sufficiency(sufficiency_df)\n\n    self.disqualification += disqualification\n    self.warnings += warnings\n    self.log_warnings()\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.df","title":"<code>df</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.df--returns","title":"Returns","text":"<pre><code>pandas.DataFrame or None: A copy of the DataFrame if it exists, otherwise None.\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.from_series--parameters","title":"Parameters","text":"<ul> <li>meter_data (pd.Series or pd.DataFrame): The meter data.</li> <li>temperature_data (pd.Series or pd.DataFrame): The temperature data.</li> <li>is_electricity_data: A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.</li> </ul>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.from_series--returns","title":"Returns","text":"<ul> <li>Data: An instance of the Data class with the dataframe populated with the corrected data, alongwith warnings and disqualifications based on the input.</li> </ul> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: Union[pd.Series, pd.DataFrame],\n    temperature_data: Union[pd.Series, pd.DataFrame],\n    is_electricity_data,\n):\n    \"\"\"\n    Create an instance of the Data class from meter data and temperature data.\n\n    Parameters\n    ----------\n\n    - meter_data (pd.Series or pd.DataFrame): The meter data.\n    - temperature_data (pd.Series or pd.DataFrame): The temperature data.\n    - is_electricity_data: A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.\n\n    Returns\n    -------\n\n    - Data: An instance of the Data class with the dataframe populated with the corrected data, alongwith warnings and disqualifications based on the input.\n    \"\"\"\n    if isinstance(meter_data, pd.Series):\n        meter_data = meter_data.to_frame()\n    if isinstance(temperature_data, pd.Series):\n        temperature_data = temperature_data.to_frame()\n    meter_data = meter_data.rename(columns={meter_data.columns[0]: \"observed\"})\n    temperature_data = temperature_data.rename(\n        columns={temperature_data.columns[0]: \"temperature\"}\n    )\n    temperature_data.index = temperature_data.index.tz_convert(\n        meter_data.index.tzinfo\n    )\n\n    if temperature_data.empty:\n        raise ValueError(\"Temperature data cannot be empty.\")\n    if meter_data.empty:\n        # reporting from_series always passes a full index of nan\n        raise ValueError(\"Meter data cannot by empty.\")\n\n    is_billing_data = False\n    if not meter_data.empty:\n        is_billing_data = compute_minimum_granularity(\n            meter_data.index, \"billing\"\n        ).startswith(\"billing\")\n\n    # first, trim the data to exclude NaNs on the outer edges of the data\n    last_meter_index = meter_data.last_valid_index()\n    if is_billing_data:\n        # preserve final NaN for billing data only\n        last = meter_data.last_valid_index()\n        if last and last != meter_data.index[-1]:\n            # TODO include warning here for non-NaN final billing row since it will be discarded\n            last_meter_index = meter_data.index[meter_data.index.get_loc(last) + 1]\n    meter_data = meter_data.loc[meter_data.first_valid_index() : last_meter_index]\n    temperature_data = temperature_data.loc[\n        temperature_data.first_valid_index() : temperature_data.last_valid_index()\n    ]\n\n    # TODO consider a refactor of the period offset calculation/slicing.\n    # it seems like a fairly dense block of code for something conceptually simple.\n    # at the very least, try to clarify variable names a bit\n\n    period_diff_first = pd.Timedelta(0)\n    period_diff_last = pd.Timedelta(0)\n    # calculate difference in period length for first and last rows in meter/temp\n    # first/last will generally be the same offset for daily/hourly, but billing can be quite variable\n    # could consider using to_offset(index.inferred_freq) if available,\n    # but the intent here is just to provide a lenient first trim.\n    # checking for consistent frequency is done later during __init__\n    if len(meter_data.index) &gt; 1 and len(temperature_data.index) &gt; 1:\n        period_meter_first = meter_data.index[1] - meter_data.index[0]\n        period_temp_first = temperature_data.index[1] - temperature_data.index[0]\n        period_diff_first = period_meter_first - period_temp_first\n\n        period_meter_last = meter_data.index[-1] - meter_data.index[-2]\n        period_temp_last = temperature_data.index[-1] - temperature_data.index[-2]\n        period_diff_last = period_meter_last - period_temp_last\n\n    # if diff is positive, meter period is longer (lower frequency)\n    zero_offset = pd.Timedelta(0)\n    meter_period_first_longer = period_diff_first &gt; zero_offset\n    meter_period_last_longer = period_diff_last &gt; zero_offset\n\n    # large period needs a buffer for the min index, and no buffer for the max index\n    # short period needs a buffer for the max index, and no buffer for the min index\n    meter_offset_first = (\n        period_diff_first if meter_period_first_longer else zero_offset\n    )\n    meter_offset_last = (\n        -period_diff_last if not meter_period_last_longer else zero_offset\n    )\n    temp_offset_first = (\n        -period_diff_first if not meter_period_first_longer else zero_offset\n    )\n    temp_offset_last = period_diff_last if meter_period_last_longer else zero_offset\n\n    # if the shorter period ends on an exact index of the longer, we accept it.\n    # the data should be DQ'd later due to insufficiency for the period\n\n    # constrain meter index to temperature index\n    temp_index_min = temperature_data.index.min() - meter_offset_first\n    temp_index_max = temperature_data.index.max() + meter_offset_last\n    meter_data = meter_data[temp_index_min:temp_index_max]\n    if meter_data.empty:\n        raise ValueError(\"Meter and temperature data are fully misaligned.\")\n\n    # if billing detected, subtract one day from final index since dataframe input assumes final row is part of period\n    if is_billing_data:\n        new_index = meter_data.index[:-1].union(\n            [(meter_data.index[-1] - pd.Timedelta(days=1))]\n        )\n        if len(new_index) == len(meter_data.index):\n            meter_data.index = new_index\n        else:\n            # handles the case of a 1 day off-cycle read at end of series\n            meter_data = meter_data[:-1]\n\n    # constrain temperature index to meter index\n    meter_index_min = meter_data.index.min() - temp_offset_first\n    meter_index_max = meter_data.index.max() + temp_offset_last\n    if is_billing_data and len(meter_data) &gt; 1:\n        # last billing period is offset by one index\n        meter_index_max = meter_data.index[-2] + temp_offset_last\n    temperature_data = temperature_data[meter_index_min:meter_index_max]\n\n    if is_billing_data:\n        # TODO consider adding misaligned data warning here if final row was not already NaN\n        meter_data.iloc[-1] = np.nan\n\n    df = pd.concat([meter_data, temperature_data], axis=1)\n    return cls(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyBaselineData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self):\n    \"\"\"\n    Logs the warnings and disqualifications associated with the data.\n\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData","title":"<code>DailyReportingData(df, is_electricity_data)</code>","text":"<p>Data class to represent Daily Reporting Data. Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it. Meter data input is optional for the reporting class.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData--parameters","title":"Parameters","text":"<ol> <li> <p>data : A dataframe having a datetime index or a datetime column with the timezone also being set.     It also requires 1 more column - 'temperature' for temperature data. Adding a column for 'observed', i.e. meter data is optional.     The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> </li> <li> <p>is_electricity_data : boolean flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> </li> </ol>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData--returns","title":"Returns","text":"<p>An instance of the DailyBaselineData class.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData--public-attributes","title":"Public Attributes","text":"<ol> <li>df : Immutable dataframe that contains the meter and temperature values for the baseline data period.</li> <li>disqualification : Serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them,                         set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</li> <li>warnings : Issues with the data, but not that will severely reduce the quality of the model built.</li> </ol>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData--public-methods","title":"Public Methods","text":"<ol> <li> <p>from_series: Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe.                 The temperature column should have values in Fahrenheit.</p> </li> <li> <p>log_warnings: View the disqualifications and warnings associated with the current data input provided.</p> </li> </ol> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    df = df.copy()\n    if \"observed\" not in df.columns:\n        df[\"observed\"] = np.nan\n\n    super().__init__(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.df","title":"<code>df</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.df--returns","title":"Returns","text":"<pre><code>pandas.DataFrame or None: A copy of the DataFrame if it exists, otherwise None.\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self):\n    \"\"\"\n    Logs the warnings and disqualifications associated with the data.\n\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data=None, tzinfo=None)</code>  <code>classmethod</code>","text":"<p>Create a DailyReportingData instance from meter data and temperature data.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.from_series--parameters","title":"Parameters","text":"<ul> <li>meter_data: pd.Series or pd.DataFrame (Optional attribute)     The meter data to be used for the DailyReportingData instance.</li> <li>temperature_data: pd.Series or pd.DataFrame (Required)     The temperature data to be used for the DailyReportingData instance.</li> <li>is_electricity_data: bool (Optional)     Flag indicating whether the meter data represents electricity data.</li> <li>tzinfo: tz (optional)     Timezone information to be used for the meter data.</li> </ul>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyReportingData.from_series--returns","title":"Returns","text":"<ul> <li>DailyReportingData     A newly created DailyReportingData instance.</li> </ul> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: Optional[Union[pd.Series, pd.DataFrame]],\n    temperature_data: Union[pd.Series, pd.DataFrame],\n    is_electricity_data: Optional[bool] = None,\n    tzinfo=None,\n):\n    \"\"\"\n    Create a DailyReportingData instance from meter data and temperature data.\n\n    Parameters\n    ----------\n\n    - meter_data: pd.Series or pd.DataFrame (Optional attribute)\n        The meter data to be used for the DailyReportingData instance.\n    - temperature_data: pd.Series or pd.DataFrame (Required)\n        The temperature data to be used for the DailyReportingData instance.\n    - is_electricity_data: bool (Optional)\n        Flag indicating whether the meter data represents electricity data.\n    - tzinfo: tz (optional)\n        Timezone information to be used for the meter data.\n\n    Returns\n    -------\n\n    - DailyReportingData\n        A newly created DailyReportingData instance.\n    \"\"\"\n    if tzinfo and meter_data is not None:\n        raise ValueError(\n            \"When passing meter data to DailyReportingData, convert its DatetimeIndex to local timezone first; `tzinfo` param should only be used in the absence of reporting meter data.\"\n        )\n    if is_electricity_data is None and meter_data is not None:\n        raise ValueError(\n            \"Must specify is_electricity_data when passing meter data.\"\n        )\n    if meter_data is None:\n        meter_data = pd.DataFrame(\n            {\"observed\": np.nan}, index=temperature_data.index\n        )\n        if tzinfo:\n            meter_data = meter_data.tz_convert(tzinfo)\n    if meter_data.empty:\n        raise ValueError(\n            \"Pass meter_data=None rather than an empty series in order to explicitly create a temperature-only reporting data instance.\"\n        )\n    return super().from_series(meter_data, temperature_data, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel","title":"<code>DailyModel(model='current', settings=None, verbose=False)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>seasonal_options</code> <code>list</code> <p>A list of seasonal options.</p> <code>day_options</code> <code>list</code> <p>A list of day options.</p> <code>combo_dictionary</code> <code>dict</code> <p>A dictionary of combinations.</p> <code>df_meter</code> <code>DataFrame</code> <p>A dataframe of meter data.</p> <code>error</code> <code>dict</code> <p>A dictionary of error metrics.</p> <code>combinations</code> <code>list</code> <p>A list of combinations.</p> <code>components</code> <code>list</code> <p>A list of components.</p> <code>fit_components</code> <code>list</code> <p>A list of fit components.</p> <code>wRMSE_base</code> <code>float</code> <p>The mean bias error for no splits.</p> <code>best_combination</code> <code>list</code> <p>The best combination of splits.</p> <code>model</code> <code>Pipeline</code> <p>The final fitted model.</p> <code>id</code> <code>str</code> <p>The index of the meter data.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use (either 'current' or 'legacy').</p> <code>'current'</code> <code>settings</code> <code>dict | None</code> <p>DailySettings to be changed.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output.</p> <code>False</code> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def __init__(\n    self,\n    model: str = \"current\",\n    settings: dict | None = None,\n    verbose: bool = False,\n):\n    \"\"\"\n    Args:\n        model: The model to use (either 'current' or 'legacy').\n        settings: DailySettings to be changed.\n        verbose: Whether to print verbose output.\n    \"\"\"\n\n    # Initialize settings\n    # Note: Model designates the base settings, it can be 'current' or 'legacy'\n    #       Settings is to be a dictionary of settings to be changed\n\n    if settings is None:\n        settings = {}\n\n    if model.replace(\" \", \"\").replace(\"_\", \".\").lower() in [\"current\", \"default\"]:\n        self.settings = default_settings(**settings)\n    elif model.replace(\" \", \"\").replace(\"_\", \".\").lower() in [\"legacy\"]:\n        self.settings = caltrack_legacy_settings(**settings)\n    else:\n        raise Exception(\n            \"Invalid 'settings' choice: must be 'current', 'default', or 'legacy'\"\n        )\n\n    # Initialize seasons and weekday/weekend\n    self.seasonal_options = [\n        [\"su_sh_wi\"],\n        [\"su\", \"sh_wi\"],\n        [\"su_sh\", \"wi\"],\n        [\"su_wi\", \"sh\"],\n        [\"su\", \"sh\", \"wi\"],\n    ]\n    self.day_options = [[\"wd\", \"we\"]]\n\n    n_week = list(range(len(self.settings.is_weekday)))\n    self.combo_dictionary = {\n        \"su\": \"summer\",\n        \"sh\": \"shoulder\",\n        \"wi\": \"winter\",\n        \"fw\": [n + 1 for n in n_week],\n        \"wd\": [n + 1 for n in n_week if self.settings.is_weekday[n + 1]],\n        \"we\": [n + 1 for n in n_week if not self.settings.is_weekday[n + 1]],\n    }\n    self.verbose = verbose\n\n    self.error = {\n        \"wRMSE\": np.nan,\n        \"RMSE\": np.nan,\n        \"MAE\": np.nan,\n        \"CVRMSE\": np.nan,\n        \"PNRMSE\": np.nan,\n    }\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.settings","title":"<code>settings = default_settings(**settings)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.seasonal_options","title":"<code>seasonal_options = [['su_sh_wi'], ['su', 'sh_wi'], ['su_sh', 'wi'], ['su_wi', 'sh'], ['su', 'sh', 'wi']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.day_options","title":"<code>day_options = [['wd', 'we']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.combo_dictionary","title":"<code>combo_dictionary = {'su': 'summer', 'sh': 'shoulder', 'wi': 'winter', 'fw': [n + 1 for n in n_week], 'wd': [n + 1 for n in n_week if self.settings.is_weekday[n + 1]], 'we': [n + 1 for n in n_week if not self.settings.is_weekday[n + 1]]}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.error","title":"<code>error = {'wRMSE': np.nan, 'RMSE': np.nan, 'MAE': np.nan, 'CVRMSE': np.nan, 'PNRMSE': np.nan}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>baseline_data</code> <code>DailyBaselineData</code> <p>DailyBaselineData object.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore disqualification errors / warnings.</p> <code>False</code> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def fit(\n    self, \n    baseline_data: DailyBaselineData, \n    ignore_disqualification: bool = False\n):\n    \"\"\"\n    Args:\n        baseline_data: DailyBaselineData object.\n        ignore_disqualification: Whether to ignore disqualification errors / warnings.\n    \"\"\"\n    if not isinstance(baseline_data, DailyBaselineData):\n        raise TypeError(\"baseline_data must be a DailyBaselineData object\")\n    baseline_data.log_warnings()\n    if baseline_data.disqualification and not ignore_disqualification:\n        raise DataSufficiencyError(\"Can't fit model on disqualified baseline data\")\n    self.baseline_timezone = baseline_data.tz\n    self.warnings = baseline_data.warnings\n    self.disqualification = baseline_data.disqualification\n    self._fit(baseline_data.df)\n    if self.error[\"CVRMSE\"] &gt; self.settings.cvrmse_threshold:\n        cvrmse_warning = EEMeterWarning(\n            qualified_name=\"eemeter.model_fit_metrics.cvrmse\",\n            description=(\n                f\"Fit model has CVRMSE &gt; {self.settings.cvrmse_threshold}\"\n            ),\n            data={\"CVRMSE\": self.error[\"CVRMSE\"]},\n        )\n        cvrmse_warning.warn()\n        self.disqualification.append(cvrmse_warning)\n    return self\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.predict","title":"<code>predict(reporting_data, ignore_disqualification=False)</code>","text":"<p>Perform initial sufficiency and typechecks before passing to private predict</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def predict(\n    self,\n    reporting_data: Union[DailyBaselineData, DailyReportingData],\n    ignore_disqualification=False,\n):\n    \"\"\"Perform initial sufficiency and typechecks before passing to private predict\"\"\"\n    if not self.is_fitted:\n        raise RuntimeError(\"Model must be fit before predictions can be made.\")\n\n    if self.disqualification and not ignore_disqualification:\n        raise DisqualifiedModelError(\n            \"Attempting to predict using disqualified model without setting ignore_disqualification=True\"\n        )\n\n    if str(self.baseline_timezone) != str(reporting_data.tz):\n        \"\"\"would be preferable to directly compare, but\n        * using str() helps accomodate mixed tzinfo implementations,\n        * the likelihood of sub-hour offset inconsistencies being relevant to the daily model is low\n        \"\"\"\n        raise ValueError(\n            \"Reporting data must use the same timezone that the model was initially fit on.\"\n        )\n\n    if not isinstance(reporting_data, (DailyBaselineData, DailyReportingData)):\n        raise TypeError(\n            \"reporting_data must be a DailyBaselineData or DailyReportingData object\"\n        )\n\n    return self._predict(reporting_data.df)\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.to_dict","title":"<code>to_dict()</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def to_dict(self):\n    return self.params.model_dump()\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.to_json","title":"<code>to_json()</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def to_json(self):\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    settings = data.get(\"settings\")\n    daily_model = cls(settings=settings)\n    info = data.get(\"info\")\n    daily_model.params = DailyModelParameters(\n        submodels=data.get(\"submodels\"),\n        info=info,\n        settings=settings,\n    )\n\n    def deserialize_warnings(warnings):\n        if not warnings:\n            return []\n        warn_list = []\n        for warning in warnings:\n            warn_list.append(\n                EEMeterWarning(\n                    qualified_name=warning.get(\"qualified_name\"),\n                    description=warning.get(\"description\"),\n                    data=warning.get(\"data\"),\n                )\n            )\n        return warn_list\n\n    daily_model.disqualification = deserialize_warnings(\n        info.get(\"disqualification\")\n    )\n    daily_model.warnings = deserialize_warnings(info.get(\"warnings\"))\n    daily_model.baseline_timezone = info.get(\"baseline_timezone\")\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_json(cls, str_data):\n    return cls.from_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.from_2_0_dict","title":"<code>from_2_0_dict(data)</code>  <code>classmethod</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_dict(cls, data):\n    daily_model = cls(model=\"legacy\")\n    daily_model.params = DailyModelParameters.from_2_0_params(data)\n    daily_model.warnings = []\n    daily_model.disqualification = []\n    daily_model.baseline_timezone = \"UTC\"\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.from_2_0_json","title":"<code>from_2_0_json(str_data)</code>  <code>classmethod</code>","text":"Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_json(cls, str_data):\n    return cls.from_2_0_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.plot","title":"<code>plot(df_eval, ax=None, title=None, figsize=None, temp_range=None)</code>","text":"<p>Plot a model fit.</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.plot--parameters","title":"Parameters","text":"<p>ax : :any:<code>matplotlib.axes.Axes</code>, optional     Existing axes to plot on. title : :any:<code>str</code>, optional     Chart title. figsize : :any:<code>tuple</code>, optional     (width, height) of chart. with_candidates : :any:<code>bool</code>     If True, also plot candidate models. temp_range : :any:<code>tuple</code>, optionl     Temperature range to plot</p>"},{"location":"reference/eemeter/eemeter/#eemeter.eemeter.models.daily.DailyModel.plot--returns","title":"Returns","text":"<p>ax : :any:<code>matplotlib.axes.Axes</code>     Matplotlib axes.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def plot(\n    self,\n    df_eval,\n    ax=None,\n    title=None,\n    figsize=None,\n    temp_range=None,\n):\n    \"\"\"Plot a model fit.\n\n    Parameters\n    ----------\n    ax : :any:`matplotlib.axes.Axes`, optional\n        Existing axes to plot on.\n    title : :any:`str`, optional\n        Chart title.\n    figsize : :any:`tuple`, optional\n        (width, height) of chart.\n    with_candidates : :any:`bool`\n        If True, also plot candidate models.\n    temp_range : :any:`tuple`, optionl\n        Temperature range to plot\n\n    Returns\n    -------\n    ax : :any:`matplotlib.axes.Axes`\n        Matplotlib axes.\n    \"\"\"\n    try:\n        from eemeter.eemeter.models.daily.plot import plot\n    except ImportError:  # pragma: no cover\n        raise ImportError(\"matplotlib is required for plotting.\")\n\n    # TODO: pass more kwargs to plotting function\n\n    plot(self, self._predict(df_eval.df))\n</code></pre>"}]}